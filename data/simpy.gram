# Simplified grammar for Python

start[mod_ty]: a=[statements] ENDMARKER { Module(a, NULL, p->arena) }
statements[asdl_seq*]: a=statement+ { seq_flatten(p, a) }

statement[asdl_seq*]: a=compound_stmt { singleton_seq(p, a) } | simple_stmt
simple_stmt[asdl_seq*]: a=small_stmt b=(';' c=small_stmt { c })* [';'] NEWLINE { seq_insert_in_front(p, a, b) }
# NOTE: assignment MUST precede expression, else the parser will get stuck;
# but it must follow all others, else reserved words will match a simple NAME.
small_stmt[stmt_ty]:
    | return_stmt
    | import_stmt
    | pass_stmt
    | raise_stmt
    | yield_stmt
    | assert_stmt
    | del_stmt
    | global_stmt
    | nonlocal_stmt
    | break_stmt
    | continue_stmt
    | assignment
    | e=expressions { _Py_Expr(e, EXTRA_EXPR(e, e)) }
compound_stmt: if_stmt | while_stmt | for_stmt | with_stmt | try_stmt | function_def | class_def

# NOTE: yield_expression may start with 'yield'; yield_expr must start with 'yield'
assignment: target ':' expression ['=' yield_expression] | (star_targets '=')+ (yield_expr | expressions) | target augassign (yield_expr | expressions)
augassign: ('+=' | '-=' | '*=' | '@=' | '/=' | '%=' | '&=' | '|=' | '^=' | '<<=' | '>>=' | '**=' | '//=')

global_stmt: 'global' NAME (',' NAME)*
nonlocal_stmt: 'nonlocal' NAME (',' NAME)*

yield_stmt: yield_expr

assert_stmt: 'assert' expression [',' expression]

del_stmt: 'del' targets  # TODO: exclude *target

pass_stmt[stmt_ty]: a='pass' { _Py_Pass(EXTRA(a, token_type, a, token_type)) }

break_stmt: a='break' { _Py_Break(EXTRA(a, token_type, a, token_type)) }

continue_stmt: a='continue' { _Py_Continue(EXTRA(a, token_type, a, token_type)) }

import_stmt: import_name | import_from
import_name[stmt_ty]: a='import' b=dotted_as_names {
    _Py_Import(seq_map_to_alias(p, b), EXTRA(a, token_type, seq_get_tail(NULL, b), alias_type)) }
# note below: the ('.' | '...') is necessary because '...' is tokenized as ELLIPSIS
import_from[stmt_ty]:
    | a='from' b=('.' | '...')* !'import' c=dotted_name 'import' d=import_from_targets {
        _Py_ImportFrom(c->v.Name.id,
                       seq_map_to_alias(p, d),
                       seq_count_dots(b),
                       EXTRA(a, token_type, seq_get_tail(NULL, d), alias_type)) }
    | e='from' f=('.' | '...')+ 'import' g=import_from_targets {
        _Py_ImportFrom(NULL,
                       seq_map_to_alias(p, g),
                       seq_count_dots(f), 
                       EXTRA(e, token_type, seq_get_tail(NULL, g), alias_type)) }
import_from_targets[asdl_seq*]:
    | '(' a=import_from_as_names ')' { a }
    | import_from_as_names
    | a='*' { singleton_seq(p, pegen_alias(alias_for_star(p),
                                           EXTRA(a, token_type, a, token_type))) }
import_from_as_names[asdl_seq*]:
    | a=import_from_as_name b=(',' c=import_from_as_name { c })* [','] { seq_insert_in_front(p, a, b) }
import_from_as_name[PegenAlias*]:
    | a=NAME 'as' b=NAME {
        pegen_alias(_Py_alias(((expr_ty) a)->v.Name.id, ((expr_ty) b)->v.Name.id, p->arena),
                    EXTRA(a, expr_type, b, expr_type)) }
    | a=NAME {
        pegen_alias(_Py_alias(((expr_ty) a)->v.Name.id, NULL, p->arena),
                    EXTRA(a, expr_type, a, expr_type)) }
dotted_as_names[asdl_seq*]: 
    | a=dotted_as_name b=(',' c=dotted_as_name { c })* { seq_insert_in_front(p, a, b) }
dotted_as_name[PegenAlias*]:
    | a=dotted_name 'as' b=NAME {
        pegen_alias(_Py_alias(a->v.Name.id, ((expr_ty) b)->v.Name.id, p->arena),
                    EXTRA(a, expr_type, b, expr_type)) }
    | a=dotted_name {
        pegen_alias(_Py_alias(a->v.Name.id, NULL, p->arena),
                    EXTRA(a, expr_type, a, expr_type)) }
dotted_name[expr_ty]:
    | a=dotted_name '.' b=NAME { join_names_with_dot(p, a, b) }
    | NAME

if_stmt[stmt_ty]:
    | a='if' b=full_expression ':' c=block d=else_block {
        _Py_If(b, c, d, EXTRA(a, token_type, seq_get_tail(NULL, d), stmt_type)) }
    | a='if' b=full_expression ':' c=block e=elif_stmt {
        _Py_If(b, c, singleton_seq(p, e), EXTRA(a, token_type, e, stmt_type)) }
    | a='if' b=full_expression ':' c=block {
        _Py_If(b, c, NULL, EXTRA(a, token_type, seq_get_tail(NULL, c), stmt_type)) }
elif_stmt[stmt_ty]:
    | 'elif' b=full_expression ':' c=block d=else_block {
        _Py_If(b, c, d, EXTRA(b, expr_type, seq_get_tail(NULL, d), stmt_type)) }
    | 'elif' b=full_expression ':' c=block e=elif_stmt {
        _Py_If(b, c, singleton_seq(p, e), EXTRA(b, expr_type, e, stmt_type)) }
    | 'elif' b=full_expression ':' c=block {
        _Py_If(b, c, NULL, EXTRA(b, expr_type, seq_get_tail(NULL, c), stmt_type)) }
else_block[asdl_seq*]: 'else' ':' b=block { b }

while_stmt: 'while' full_expression ':' block [else_block]

for_stmt: [ASYNC] 'for' star_targets 'in' expressions ':' block [else_block]

with_stmt: [ASYNC] 'with' expression ['as' target] (',' [expression ['as' target]])* ':' block

try_stmt: try_block finally_block | try_block except_block+ [else_block] [finally_block]
try_block: 'try' ':' block
except_block: 'except' [expression ['as' target]] ':' block
finally_block: 'finally' ':' block

return_stmt: 'return' [expressions]

raise_stmt: 'raise' [expression ['from' expression]]

function_def: [decorators] [ASYNC] 'def' NAME '(' [parameters] ')' ['->' annotation] ':' block

parameters: ( slash_without_default [',' plain_names] [',' names_with_default] [',' [star_etc]]
            | slash_with_default [',' names_with_default] [',' [star_etc]]
            | plain_names [',' names_with_default] [',' [star_etc]]
            | names_with_default [',' [star_etc]]
            | star_etc
            )
slash_without_default: plain_names ',' '/'
slash_with_default: [plain_names ','] names_with_default ',' '/'
names_with_default: name_with_default (',' name_with_default)*
plain_names: plain_name !'=' (',' plain_name !'=')*
star_etc: ( '*' NAME [':' annotation] (',' plain_name ['=' expression])* [',' kwds] [',']
          | '*' (',' plain_name ['=' expression])+ [',' kwds] [',']
          | kwds [',']
          )
name_with_default: plain_name '=' expression
plain_name: NAME [':' annotation]
kwds: '**' NAME [':' annotation]
annotation: expression

decorators: ('@' factor NEWLINE)+

class_def: [decorators] 'class' NAME ['(' [arguments] ')'] ':' block

block[asdl_seq*]: simple_stmt | NEWLINE INDENT a=statements DEDENT { a }

star_full_expressions: (star_full_expression) (',' (star_full_expression))* [',']
expressions[expr_ty]:
    | '*' bitwise_or (',' ('*' bitwise_or | expression))+ [',']
    | '*' bitwise_or ','
    | '*' bitwise_or
    | expression (',' ('*' bitwise_or | expression))+ [',']
    | expression ','
    | expression

star_full_expression: '*' bitwise_or | full_expression
full_expression: NAME ':=' expression | expression
yield_expression: yield_expr | expression
expression[expr_ty]:
    | lambdef
    | a=disjunction 'if' b=disjunction 'else' c=expression { _Py_IfExp(b, a, c, EXTRA_EXPR(a, c)) }
    | disjunction
lambdef: 'lambda' [lambda_parameters] ':' expression

lambda_parameters: ( lambda_slash_without_default [',' lambda_plain_names] [',' lambda_names_with_default] [',' [lambda_star_etc]]
                   | lambda_slash_with_default [',' lambda_names_with_default] [',' [lambda_star_etc]]
                   | lambda_plain_names [',' lambda_names_with_default] [',' [lambda_star_etc]]
                   | lambda_names_with_default [',' [lambda_star_etc]]
                   | lambda_star_etc
                   )
lambda_slash_without_default: lambda_plain_names ',' '/'
lambda_slash_with_default: [lambda_plain_names ','] lambda_names_with_default ',' '/'
lambda_names_with_default: lambda_name_with_default (',' lambda_name_with_default)*
lambda_plain_names: NAME !'=' (',' NAME !'=')*
lambda_star_etc: ( '*' NAME (',' NAME ['=' expression])* [',' '**' NAME] [',']
                 | '*' (',' NAME ['=' expression])+ [',' '**' NAME] [',']
                 | '**' NAME [',']
                 )
lambda_name_with_default: NAME '=' expression

disjunction[expr_ty]:
    | a=conjunction b=('or' c=conjunction { c })+ { _Py_BoolOp(
        Or,
        seq_insert_in_front(p, a, b),
        EXTRA_EXPR(a, seq_get_tail(NULL, b))) }
    | conjunction
conjunction[expr_ty]:
    | a=inversion b=('and' c=inversion { c })+ { _Py_BoolOp(
        And,
        seq_insert_in_front(p, a, b),
        EXTRA_EXPR(a, seq_get_tail(NULL, b))) }
    | inversion
inversion[expr_ty]:
    | a='not' b=inversion { _Py_UnaryOp(Not, b, EXTRA(a, token_type, b, expr_type)) }
    | comparison
comparison[expr_ty]:
    | a=bitwise_or b=compare_op_bitwise_or_pair+ {
        Pegen_Compare(p, a, b) }
    | bitwise_or
compare_op_bitwise_or_pair[CmpopExprPair*]:
    | eq_bitwise_or
    | noteq_bitwise_or
    | lte_bitwise_or
    | lt_bitwise_or
    | gte_bitwise_or
    | gt_bitwise_or
    | notin_bitwise_or
    | in_bitwise_or
    | isnot_bitwise_or
    | is_bitwise_or
eq_bitwise_or[CmpopExprPair*]: '==' a=bitwise_or { cmpop_expr_pair(p, Eq, a) }
noteq_bitwise_or[CmpopExprPair*]: '!=' a=bitwise_or { cmpop_expr_pair(p, NotEq, a) }
lte_bitwise_or[CmpopExprPair*]: '<=' a=bitwise_or { cmpop_expr_pair(p, LtE, a) }
lt_bitwise_or[CmpopExprPair*]: '<' a=bitwise_or { cmpop_expr_pair(p, Lt, a) }
gte_bitwise_or[CmpopExprPair*]: '>=' a=bitwise_or { cmpop_expr_pair(p, GtE, a) }
gt_bitwise_or[CmpopExprPair*]: '>' a=bitwise_or { cmpop_expr_pair(p, Gt, a) }
notin_bitwise_or[CmpopExprPair*]: 'not' 'in' a=bitwise_or { cmpop_expr_pair(p, NotIn, a) }
in_bitwise_or[CmpopExprPair*]: 'in' a=bitwise_or { cmpop_expr_pair(p, In, a) }
isnot_bitwise_or[CmpopExprPair*]: 'is' 'not' a=bitwise_or { cmpop_expr_pair(p, IsNot, a) }
is_bitwise_or[CmpopExprPair*]: 'is' a=bitwise_or { cmpop_expr_pair(p, Is, a) }

bitwise_or[expr_ty]: 
    | a=bitwise_or '|' b=bitwise_xor { _Py_BinOp(a, BitOr, b, EXTRA_EXPR(a, b)) }
    | bitwise_xor
bitwise_xor[expr_ty]:
    | a=bitwise_xor '^' b=bitwise_and { _Py_BinOp(a, BitXor, b, EXTRA_EXPR(a, b)) }
    | bitwise_and 
bitwise_and[expr_ty]:
    | a=bitwise_and '&' b=shift_expr { _Py_BinOp(a, BitAnd, b, EXTRA_EXPR(a, b)) }
    | shift_expr 
shift_expr[expr_ty]:
    | a=shift_expr '<<' b=sum { _Py_BinOp(a, LShift, b, EXTRA_EXPR(a, b)) }
    | a=shift_expr '>>' b=sum { _Py_BinOp(a, RShift, b, EXTRA_EXPR(a, b)) }
    | sum

sum[expr_ty]:
    | a=sum '+' b=term { _Py_BinOp(a, Add, b, EXTRA_EXPR(a, b)) }
    | a=sum '-' b=term { _Py_BinOp(a, Sub, b, EXTRA_EXPR(a, b)) }
    | term
term[expr_ty]:
    | a=term '*' b=factor { _Py_BinOp(a, Mult, b, EXTRA_EXPR(a, b)) }
    | a=term '/' b=factor { _Py_BinOp(a, Div, b, EXTRA_EXPR(a, b)) }
    | a=term '//' b=factor { _Py_BinOp(a, FloorDiv, b, EXTRA_EXPR(a, b)) }
    | a=term '%' b=factor { _Py_BinOp(a, Mod, b, EXTRA_EXPR(a, b)) }
    | a=term '@' b=factor { _Py_BinOp(a, MatMult, b, EXTRA_EXPR(a, b)) }
    | factor
factor[expr_ty]:
    | a='+' b=factor { _Py_UnaryOp(UAdd, b, EXTRA(a, token_type, b, expr_type)) }
    | a='-' b=factor { _Py_UnaryOp(USub, b, EXTRA(a, token_type, b, expr_type)) }
    | a='~' b=factor { _Py_UnaryOp(Invert, b, EXTRA(a, token_type, b, expr_type)) }
    | power
power[expr_ty]:
    | a=primary '**' b=factor { _Py_BinOp(a, Pow, b, EXTRA_EXPR(a, b)) }
    | primary 
primary[expr_ty]:
    | !'await' a=atom !'.' !'(' !'[' { a }
    | [AWAIT] atom ('.' NAME | '[' slices ']' | '(' [arguments] ')')*

slices: slice (',' slice)* [',']
slice: [expression] ':' [expression] [':' [expression]] | expression
# STRING+'s output is just a hack for now 
atom[expr_ty]:
    | list
    | listcomp
    | tuple
    | group
    | genexp
    | set
    | setcomp
    | dict
    | dictcomp
    | NAME
    | a=STRING+ { asdl_seq_GET(a, 0) }
    | NUMBER
    | '...'
list: '[' [star_full_expressions] ']'
listcomp: '[' full_expression for_if_clauses ']'
tuple: '(' [star_full_expression ',' [star_full_expressions]] ')'
group: '(' (yield_expr | full_expression) ')'
genexp: '(' expression for_if_clauses ')'
set: '{' expressions '}'
setcomp: '{' expression for_if_clauses '}'
dict: '{' [kvpairs] '}'
dictcomp: '{' kvpair for_if_clauses '}'
kvpairs: kvpair (',' kvpair)* [',']
kvpair: '**' bitwise_or | expression ':' expression
for_if_clauses: ([ASYNC] 'for' star_targets 'in' expression ('if' expression)*)+

yield_expr: 'yield' 'from' expression | 'yield' [expressions]

arguments: expression for_if_clauses | args [',']
args: '*' expression [',' args] | kwargs | posarg [',' args]  # Weird to make it work
kwargs: kwarg (',' kwarg)*
posarg: full_expression | '*' expression
kwarg: NAME '=' expression | '*' expression | '**' expression

# NOTE: star_targets may contain *NAME, targets may not.
# NOTE: the !'in' is to handle "for x, in ...".
# TODO: things like {k: v}[k] = v should also be acceptable [star] targets.
star_targets: star_target (',' !'in' star_target)* [',']
star_target: '*' bitwise_or | atom t_tail+ | star_atom t_tail*
star_atom: NAME | '(' [star_targets] ')' | '[' [star_targets] ']'

targets: target (',' target)* [',']
target: atom t_tail+ | t_atom t_tail*
t_atom: NAME | '(' [targets] ')' | '[' [targets] ']'

t_tail: call_tail* (attr_tail | index_tail)
call_tail: '(' ~ [arguments] ')'
attr_tail: '.' NAME
index_tail: '[' ~ slices ']'
