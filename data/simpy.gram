# Simplified grammar for Python

start[mod_ty]: a=[statements] ENDMARKER { Module(a, NULL, p->arena) }
statements[asdl_seq*]: a=statement+ { seq_flatten(p, a) }

statement[asdl_seq*]: a=compound_stmt { singleton_seq(p, a) } | simple_stmt
simple_stmt[asdl_seq*]: a=';'.small_stmt+ [';'] NEWLINE { a }
# NOTE: assignment MUST precede expression, else the parser will get stuck;
# but it must follow all others, else reserved words will match a simple NAME.
small_stmt[stmt_ty]:
    | return_stmt
    | import_stmt
    | pass_stmt
    | raise_stmt
    | yield_stmt
    | assert_stmt
    | del_stmt
    | global_stmt
    | nonlocal_stmt
    | break_stmt
    | continue_stmt
    | assignment
    | e=expressions { _Py_Expr(e, EXTRA_EXPR(e, e)) }
compound_stmt[stmt_ty]: if_stmt | while_stmt | for_stmt | with_stmt | try_stmt | function_def | class_def

# NOTE: yield_expression may start with 'yield'; yield_expr must start with 'yield'
assignment:
    | !'lambda' a=target ':' b=expression '=' c=yield_expression {
         _Py_AnnAssign(construct_assign_target(p, a), b, c,
         a->kind == Name_kind ? 1 : 0, EXTRA_EXPR(a, c)) }
    | !'lambda' a=target ':' b=expression {
         _Py_AnnAssign(construct_assign_target(p, a), b, NULL,
         a->kind == Name_kind ? 1 : 0, EXTRA_EXPR(a, b)) }
    | a=(z=star_targets '=' { z })+ b=(yield_expr | expressions) {
         _Py_Assign(a, b, NULL, EXTRA_EXPR(seq_get_head(NULL, a), b)) }
    | a=target b=augassign c=(yield_expr | expressions) {
         _Py_AugAssign(store_name(p, a), b->kind, c, EXTRA_EXPR(a, c)) }

augassign[AugOperator*]:
    | '+=' {augoperator(p, Add)}
    | '-=' {augoperator(p, Sub)}
    | '*=' {augoperator(p, Mult)}
    | '@=' {augoperator(p, MatMult)}
    | '/=' {augoperator(p, Div)}
    | '%=' {augoperator(p, Mod)}
    | '&=' {augoperator(p, BitAnd)}
    | '|=' {augoperator(p, BitOr)}
    | '^=' {augoperator(p, BitXor)}
    | '<<=' {augoperator(p, LShift)}
    | '>>=' {augoperator(p, RShift)}
    | '**=' {augoperator(p, Pow)}
    | '//=' {augoperator(p, FloorDiv)}

global_stmt[stmt_ty]: a='global' b=','.NAME+ {
    _Py_Global(map_names_to_ids(p, b), EXTRA(a, token_type, seq_get_tail(NULL, b), expr_type)) }
nonlocal_stmt[stmt_ty]: a='nonlocal' b=','.NAME+ {
    _Py_Nonlocal(map_names_to_ids(p, b), EXTRA(a, token_type, seq_get_tail(NULL, b), expr_type)) }

yield_stmt[stmt_ty]: y=yield_expr { _Py_Expr(y, EXTRA_EXPR(y, y)) }

assert_stmt[stmt_ty]:
    | a='assert' b=expression ',' c=expression { _Py_Assert(b, c, EXTRA(a, token_type, c, expr_type)) }
    | a='assert' b=expression { _Py_Assert(b, NULL, EXTRA(a, token_type, b, expr_type)) }

del_stmt[stmt_ty]: a='del' b=targets { # TODO: exclude *target
    _Py_Delete(map_targets_to_del_names(p, b), EXTRA(a, token_type, seq_get_tail(NULL, b), expr_type)) }

pass_stmt[stmt_ty]: a='pass' { _Py_Pass(EXTRA(a, token_type, a, token_type)) }

break_stmt[stmt_ty]: a='break' { _Py_Break(EXTRA(a, token_type, a, token_type)) }

continue_stmt[stmt_ty]: a='continue' { _Py_Continue(EXTRA(a, token_type, a, token_type)) }

import_stmt[stmt_ty]: import_name | import_from
import_name[stmt_ty]: a='import' b=dotted_as_names {
    _Py_Import(extract_orig_aliases(p, b), EXTRA(a, token_type, seq_get_tail(NULL, b), alias_type)) }
# note below: the ('.' | '...') is necessary because '...' is tokenized as ELLIPSIS
import_from[stmt_ty]:
    | a='from' b=('.' | '...')* !'import' c=dotted_name 'import' d=import_from_targets {
        _Py_ImportFrom(c->v.Name.id,
                       extract_orig_aliases(p, d),
                       seq_count_dots(b),
                       EXTRA(a, token_type, seq_get_tail(NULL, d), alias_type)) }
    | e='from' f=('.' | '...')+ 'import' g=import_from_targets {
        _Py_ImportFrom(NULL,
                       extract_orig_aliases(p, g),
                       seq_count_dots(f), 
                       EXTRA(e, token_type, seq_get_tail(NULL, g), alias_type)) }
import_from_targets[asdl_seq*]:
    | '(' a=import_from_as_names ')' { a }
    | import_from_as_names
    | a='*' { singleton_seq(p, pegen_alias(alias_for_star(p),
                                           EXTRA(a, token_type, a, token_type))) }
import_from_as_names[asdl_seq*]:
    | a=','.import_from_as_name+ [','] { a }
import_from_as_name[PegenAlias*]:
    | a=NAME 'as' b=NAME {
        pegen_alias(_Py_alias(((expr_ty) a)->v.Name.id, ((expr_ty) b)->v.Name.id, p->arena),
                    EXTRA(a, expr_type, b, expr_type)) }
    | a=NAME {
        pegen_alias(_Py_alias(((expr_ty) a)->v.Name.id, NULL, p->arena),
                    EXTRA(a, expr_type, a, expr_type)) }
dotted_as_names[asdl_seq*]: 
    | a=','.dotted_as_name+ { a }
dotted_as_name[PegenAlias*]:
    | a=dotted_name 'as' b=NAME {
        pegen_alias(_Py_alias(a->v.Name.id, ((expr_ty) b)->v.Name.id, p->arena),
                    EXTRA(a, expr_type, b, expr_type)) }
    | a=dotted_name {
        pegen_alias(_Py_alias(a->v.Name.id, NULL, p->arena),
                    EXTRA(a, expr_type, a, expr_type)) }
dotted_name[expr_ty]:
    | a=dotted_name '.' b=NAME { join_names_with_dot(p, a, b) }
    | NAME

if_stmt[stmt_ty]:
    | a='if' b=named_expression ':' c=block d=else_block {
        _Py_If(b, c, d, EXTRA(a, token_type, seq_get_tail(NULL, d), stmt_type)) }
    | a='if' b=named_expression ':' c=block e=elif_stmt {
        _Py_If(b, c, singleton_seq(p, e), EXTRA(a, token_type, e, stmt_type)) }
    | a='if' b=named_expression ':' c=block {
        _Py_If(b, c, NULL, EXTRA(a, token_type, seq_get_tail(NULL, c), stmt_type)) }
elif_stmt[stmt_ty]:
    | 'elif' b=named_expression ':' c=block d=else_block {
        _Py_If(b, c, d, EXTRA(b, expr_type, seq_get_tail(NULL, d), stmt_type)) }
    | 'elif' b=named_expression ':' c=block e=elif_stmt {
        _Py_If(b, c, singleton_seq(p, e), EXTRA(b, expr_type, e, stmt_type)) }
    | 'elif' b=named_expression ':' c=block {
        _Py_If(b, c, NULL, EXTRA(b, expr_type, seq_get_tail(NULL, c), stmt_type)) }
else_block[asdl_seq*]: 'else' ':' b=block { b }

while_stmt[stmt_ty]:
    | a='while' ex=named_expression ':' b=block el=else_block {
        _Py_While(ex, b, el, EXTRA(a, token_type, seq_get_tail(NULL, el), stmt_type)) }
    | a='while' ex=named_expression ':' b=block {
        _Py_While(ex, b, NULL, EXTRA(a, token_type, seq_get_tail(NULL, b), stmt_type)) }

for_stmt[stmt_ty]:
    | a=ASYNC 'for' t=star_targets 'in' ex=expressions ':' b=block el=else_block {
        _Py_AsyncFor(t, ex, b, el, NULL, EXTRA(a, token_type, seq_get_tail(NULL, el), stmt_type)) }
    | a=ASYNC 'for' t=star_targets 'in' ex=expressions ':' b=block {
        _Py_AsyncFor(t, ex, b, NULL, NULL, EXTRA(a, token_type, seq_get_tail(NULL, b), stmt_type)) }
    | a='for' t=star_targets 'in' ex=expressions ':' b=block el=else_block {
        _Py_For(t, ex, b, el, NULL, EXTRA(a, token_type, seq_get_tail(NULL, el), stmt_type)) }
    | a='for' t=star_targets 'in' ex=expressions ':' b=block {
        _Py_For(t, ex, b, NULL, NULL, EXTRA(a, token_type, seq_get_tail(NULL, b), stmt_type)) }

with_stmt[stmt_ty]:
    | a=ASYNC 'with' '(' b=','.with_item+ ')' ':' c=block {
        _Py_AsyncWith(b, c, NULL, EXTRA(a, token_type, seq_get_tail(NULL, c), stmt_type)) }
    | a=ASYNC 'with' b=','.with_item+ ':' c=block {
        _Py_AsyncWith(b, c, NULL, EXTRA(a, token_type, seq_get_tail(NULL, c), stmt_type)) }
    | a='with' '(' b=','.with_item+ ')' ':' c=block {
        _Py_With(b, c, NULL, EXTRA(a, token_type, seq_get_tail(NULL, c), stmt_type)) }
    | a='with' b=','.with_item+ ':' c=block {
        _Py_With(b, c, NULL, EXTRA(a, token_type, seq_get_tail(NULL, c), stmt_type)) }
with_item[withitem_ty]:
    | e=expression o=['as' t=target { t }] { _Py_withitem(e, store_name(p, o), p->arena) }

try_stmt[stmt_ty]:
    | a='try' ':' b=block ex=except_block+ el=else_block f=finally_block {
        _Py_Try(b, ex, el, f, EXTRA(a, token_type, seq_get_tail(NULL, f), stmt_type)) }
    | a='try' ':' b=block ex=except_block+ el=else_block {
        _Py_Try(b, ex, el, NULL, EXTRA(a, token_type, seq_get_tail(NULL, el), stmt_type)) }
    | a='try' ':' b=block ex=except_block+ f=finally_block {
        _Py_Try(b, ex, NULL, f, EXTRA(a, token_type, seq_get_tail(NULL, f), stmt_type)) }
    | a='try' ':' b=block ex=except_block+ {
        _Py_Try(b, ex, NULL, NULL, EXTRA(a, token_type, seq_get_tail(NULL, ex), excepthandler_type)) }
    | a='try' ':' b=block f=finally_block {
        _Py_Try(b, NULL, NULL, f, EXTRA(a, token_type, seq_get_tail(NULL, f), stmt_type)) }
except_block[excepthandler_ty]:
    | a='except' e=expression 'as' t=target ':' b=block {
        _Py_ExceptHandler(e, t->v.Name.id, b, EXTRA(a, token_type, seq_get_tail(NULL, b), stmt_type)) }
    | a='except' e=expression ':' b=block {
        _Py_ExceptHandler(e, NULL, b, EXTRA(a, token_type, seq_get_tail(NULL, b), stmt_type)) }
    | a='except' ':' b=block {
        _Py_ExceptHandler(NULL, NULL, b, EXTRA(a, token_type, seq_get_tail(NULL, b), stmt_type)) }
finally_block[asdl_seq*]: 'finally' ':' a=block { a }

return_stmt[stmt_ty]:
    | a='return' b=expressions { _Py_Return(b, EXTRA(a, token_type, b, expr_type)) }
    | a='return' { _Py_Return(NULL, EXTRA(a, token_type, a, token_type)) }

raise_stmt[stmt_ty]:
    | a='raise' b=expression 'from' c=expression { _Py_Raise(b, c, EXTRA(a, token_type, c, expr_type)) }
    | a='raise' b=expression { _Py_Raise(b, NULL, EXTRA(a, token_type, b, expr_type)) }
    | a='raise' { _Py_Raise(NULL, NULL, EXTRA(a, token_type, a, token_type)) }

function_def[stmt_ty]:
    | d=[decorators] s=ASYNC 'def' n=NAME '(' params=parameters ')' a=['->' z=annotation { z }] ':' b=block {
        _Py_AsyncFunctionDef(((expr_ty) n)->v.Name.id, params, b, d, a, NULL,
                             EXTRA(s, token_type, seq_get_tail(NULL, b), stmt_type)) }
    | d=[decorators] s=ASYNC 'def' n=NAME '(' ')' a=['->' z=annotation { z }] ':' b=block {
        _Py_AsyncFunctionDef(((expr_ty) n)->v.Name.id, empty_arguments(p), b, d, a, NULL,
                             EXTRA(s, token_type, seq_get_tail(NULL, b), stmt_type)) }
    | d=[decorators] s='def' n=NAME '(' params=parameters ')' a=['->' z=annotation { z }] ':' b=block {
        _Py_FunctionDef(((expr_ty) n)->v.Name.id, params, b, d, a, NULL,
                        EXTRA(s, token_type, seq_get_tail(NULL, b), stmt_type)) }
    | d=[decorators] s='def' n=NAME '(' ')' a=['->' z=annotation { z }] ':' b=block {
        _Py_FunctionDef(((expr_ty) n)->v.Name.id, empty_arguments(p), b, d, a, NULL,
                        EXTRA(s, token_type, seq_get_tail(NULL, b), stmt_type)) }

parameters[arguments_ty]:
    | a=slash_without_default b=[',' x=plain_names { x }] c=[',' y=names_with_default { y }] d=[',' z=[star_etc] { z }] {
        make_arguments(p, a, NULL, b, c, d) }
    | a=slash_with_default b=[',' y=names_with_default { y }] c=[',' z=[star_etc] { z }] {
        make_arguments(p, NULL, a, NULL, b, c) }
    | a=plain_names b=[',' y=names_with_default { y }] c=[',' z=[star_etc] { z }] {
        make_arguments(p, NULL, NULL, a, b, c) }
    | a=names_with_default b=[',' z=[star_etc] { z }] { make_arguments(p, NULL, NULL, NULL, a, b)}
    | a=star_etc { make_arguments(p, NULL, NULL, NULL, NULL, a) }
slash_without_default[asdl_seq*]: a=plain_names ',' '/' { a }
slash_with_default[SlashWithDefault*]: a=[n=plain_names ',' { n }] b=names_with_default ',' '/' {
    slash_with_default(p, a, b) }
star_etc[StarEtc*]:
    | '*' a=plain_name b=name_with_optional_default* c=[',' d=kwds { d }] [','] {
        star_etc(p, a, b, c) }
    | '*' b=name_with_optional_default+ c=[',' d=kwds { d }] [','] {
        star_etc(p, NULL, b, c) }
    | a=kwds [','] { star_etc(p, NULL, NULL, a) }
name_with_optional_default[NameDefaultPair*]:
    | ',' a=plain_name b=['=' e=expression { e }] { name_default_pair(p, a, b) }
names_with_default[asdl_seq*]: a=','.name_with_default+ { a }
name_with_default[NameDefaultPair*]:
    | n=plain_name '=' e=expression { name_default_pair(p, n, e) }
plain_names[asdl_seq*]: a=','.(plain_name !'=')+ { a }
plain_name[arg_ty]:
    | a=NAME ':' b=annotation { _Py_arg(((expr_ty) a)->v.Name.id, b, NULL, EXTRA_EXPR(a, b)) }
    | a=NAME { _Py_arg(((expr_ty) a)->v.Name.id, NULL, NULL, EXTRA_EXPR(a, a)) }
kwds[arg_ty]:
    | '**' a=NAME ':' b=annotation { _Py_arg(((expr_ty) a)->v.Name.id, b, NULL, EXTRA_EXPR(a, b)) }
    | '**' a=NAME { _Py_arg(((expr_ty) a)->v.Name.id, NULL, NULL, EXTRA_EXPR(a, a)) }
annotation[expr_ty]: expression

decorators[asdl_seq*]: a=('@' f=factor NEWLINE { f })+ { a }

class_def: [decorators] 'class' NAME ['(' [arguments] ')'] ':' block

block[asdl_seq*]: simple_stmt | NEWLINE INDENT a=statements DEDENT { a }

expressions_list[asdl_seq*]: a=','.star_expression+ [','] { a }
expressions[expr_ty]:
    | a=star_expression b=(',' c=star_expression { c })+ [','] {
        _Py_Tuple(seq_insert_in_front(p, a, b), Load, EXTRA_EXPR(a, seq_get_tail(NULL, b))) }
    | a=star_expression ',' { _Py_Tuple(singleton_seq(p, a), Load, EXTRA_EXPR(a, a)) }
    | star_expression
star_expression[expr_ty]:
    | a='*' b=bitwise_or { _Py_Starred(b, Load, EXTRA(a, token_type, b, expr_type)) }
    | expression

star_named_expressions[asdl_seq*]: a=','.star_named_expression+ [','] { a }
star_named_expression[expr_ty]:
    | a='*' b=bitwise_or { _Py_Starred(b, Load, EXTRA(a, token_type, b, expr_type)) }
    | named_expression
named_expression[expr_ty]:
    | a=NAME ':=' b=expression { _Py_NamedExpr(a, b, EXTRA_EXPR(a, b)) }
    | expression
yield_expression: yield_expr | expression
expression[expr_ty]:
    | lambdef
    | a=disjunction 'if' b=disjunction 'else' c=expression { _Py_IfExp(b, a, c, EXTRA_EXPR(a, c)) }
    | disjunction

lambdef[expr_ty]: 
    | a='lambda' ':' c=expression {_Py_Lambda(empty_arguments(p), c, EXTRA(a, token_type, c, expr_type))}
    | a='lambda' b=lambda_parameters ':' c=expression {_Py_Lambda(b, c, EXTRA(a, token_type, c, expr_type))}
lambda_parameters[arguments_ty]:
    | a=lambda_slash_without_default b=[',' x=lambda_plain_names { x }] c=[',' y=lambda_names_with_default { y }] d=[',' z=[lambda_star_etc] { z }] {
        make_arguments(p, a, NULL, b, c, d) }
    | a=lambda_slash_with_default b=[',' y=lambda_names_with_default { y }] c=[',' z=[lambda_star_etc] { z }] {
        make_arguments(p, NULL, a, NULL, b, c) }
    | a=lambda_plain_names b=[',' y=lambda_names_with_default { y }] c=[',' z=[lambda_star_etc] { z }] {
        make_arguments(p, NULL, NULL, a, b, c) }
    | a=lambda_names_with_default b=[',' z=[lambda_star_etc] { z }] { make_arguments(p, NULL, NULL, NULL, a, b)}
    | a=lambda_star_etc { make_arguments(p, NULL, NULL, NULL, NULL, a) }
lambda_slash_without_default[asdl_seq*]: a=lambda_plain_names ',' '/' { a }
lambda_slash_with_default[SlashWithDefault*]: a=[n=lambda_plain_names ',' { n }] b=lambda_names_with_default ',' '/' {
    slash_with_default(p, a, b) }
lambda_star_etc[StarEtc*]:
    | '*' a=lambda_plain_name b=lambda_name_with_optional_default* c=[',' d=lambda_kwds { d }] [','] {
        star_etc(p, a, b, c) }
    | '*' b=lambda_name_with_optional_default+ c=[',' d=lambda_kwds { d }] [','] {
        star_etc(p, NULL, b, c) }
    | a=lambda_kwds [','] { star_etc(p, NULL, NULL, a) }
lambda_name_with_optional_default[NameDefaultPair*]:
    | ',' a=lambda_plain_name b=['=' e=expression { e }] { name_default_pair(p, a, b) }
lambda_names_with_default[asdl_seq*]: a=','.lambda_name_with_default+ { a }
lambda_name_with_default[NameDefaultPair*]:
    | n=lambda_plain_name '=' e=expression { name_default_pair(p, n, e) }
lambda_plain_names[asdl_seq*]: a=','.(lambda_plain_name !'=')+ { a }
lambda_plain_name[arg_ty]: a=NAME { _Py_arg(((expr_ty) a)->v.Name.id, NULL, NULL, EXTRA_EXPR(a, a)) }
lambda_kwds[arg_ty]: '**' a=NAME { _Py_arg(((expr_ty) a)->v.Name.id, NULL, NULL, EXTRA_EXPR(a, a)) }

disjunction[expr_ty]:
    | a=conjunction b=('or' c=conjunction { c })+ { _Py_BoolOp(
        Or,
        seq_insert_in_front(p, a, b),
        EXTRA_EXPR(a, seq_get_tail(NULL, b))) }
    | conjunction
conjunction[expr_ty]:
    | a=inversion b=('and' c=inversion { c })+ { _Py_BoolOp(
        And,
        seq_insert_in_front(p, a, b),
        EXTRA_EXPR(a, seq_get_tail(NULL, b))) }
    | inversion
inversion[expr_ty]:
    | a='not' b=inversion { _Py_UnaryOp(Not, b, EXTRA(a, token_type, b, expr_type)) }
    | comparison
comparison[expr_ty]:
    | a=bitwise_or b=compare_op_bitwise_or_pair+ {
        Pegen_Compare(p, a, b) }
    | bitwise_or
compare_op_bitwise_or_pair[CmpopExprPair*]:
    | eq_bitwise_or
    | noteq_bitwise_or
    | lte_bitwise_or
    | lt_bitwise_or
    | gte_bitwise_or
    | gt_bitwise_or
    | notin_bitwise_or
    | in_bitwise_or
    | isnot_bitwise_or
    | is_bitwise_or
eq_bitwise_or[CmpopExprPair*]: '==' a=bitwise_or { cmpop_expr_pair(p, Eq, a) }
noteq_bitwise_or[CmpopExprPair*]: '!=' a=bitwise_or { cmpop_expr_pair(p, NotEq, a) }
lte_bitwise_or[CmpopExprPair*]: '<=' a=bitwise_or { cmpop_expr_pair(p, LtE, a) }
lt_bitwise_or[CmpopExprPair*]: '<' a=bitwise_or { cmpop_expr_pair(p, Lt, a) }
gte_bitwise_or[CmpopExprPair*]: '>=' a=bitwise_or { cmpop_expr_pair(p, GtE, a) }
gt_bitwise_or[CmpopExprPair*]: '>' a=bitwise_or { cmpop_expr_pair(p, Gt, a) }
notin_bitwise_or[CmpopExprPair*]: 'not' 'in' a=bitwise_or { cmpop_expr_pair(p, NotIn, a) }
in_bitwise_or[CmpopExprPair*]: 'in' a=bitwise_or { cmpop_expr_pair(p, In, a) }
isnot_bitwise_or[CmpopExprPair*]: 'is' 'not' a=bitwise_or { cmpop_expr_pair(p, IsNot, a) }
is_bitwise_or[CmpopExprPair*]: 'is' a=bitwise_or { cmpop_expr_pair(p, Is, a) }

bitwise_or[expr_ty]: 
    | a=bitwise_or '|' b=bitwise_xor { _Py_BinOp(a, BitOr, b, EXTRA_EXPR(a, b)) }
    | bitwise_xor
bitwise_xor[expr_ty]:
    | a=bitwise_xor '^' b=bitwise_and { _Py_BinOp(a, BitXor, b, EXTRA_EXPR(a, b)) }
    | bitwise_and 
bitwise_and[expr_ty]:
    | a=bitwise_and '&' b=shift_expr { _Py_BinOp(a, BitAnd, b, EXTRA_EXPR(a, b)) }
    | shift_expr 
shift_expr[expr_ty]:
    | a=shift_expr '<<' b=sum { _Py_BinOp(a, LShift, b, EXTRA_EXPR(a, b)) }
    | a=shift_expr '>>' b=sum { _Py_BinOp(a, RShift, b, EXTRA_EXPR(a, b)) }
    | sum

sum[expr_ty]:
    | a=sum '+' b=term { _Py_BinOp(a, Add, b, EXTRA_EXPR(a, b)) }
    | a=sum '-' b=term { _Py_BinOp(a, Sub, b, EXTRA_EXPR(a, b)) }
    | term
term[expr_ty]:
    | a=term '*' b=factor { _Py_BinOp(a, Mult, b, EXTRA_EXPR(a, b)) }
    | a=term '/' b=factor { _Py_BinOp(a, Div, b, EXTRA_EXPR(a, b)) }
    | a=term '//' b=factor { _Py_BinOp(a, FloorDiv, b, EXTRA_EXPR(a, b)) }
    | a=term '%' b=factor { _Py_BinOp(a, Mod, b, EXTRA_EXPR(a, b)) }
    | a=term '@' b=factor { _Py_BinOp(a, MatMult, b, EXTRA_EXPR(a, b)) }
    | factor
factor[expr_ty]:
    | a='+' b=factor { _Py_UnaryOp(UAdd, b, EXTRA(a, token_type, b, expr_type)) }
    | a='-' b=factor { _Py_UnaryOp(USub, b, EXTRA(a, token_type, b, expr_type)) }
    | a='~' b=factor { _Py_UnaryOp(Invert, b, EXTRA(a, token_type, b, expr_type)) }
    | power
power[expr_ty]:
    | a=primary '**' b=factor { _Py_BinOp(a, Pow, b, EXTRA_EXPR(a, b)) }
    | primary 
primary[expr_ty]:
    | !'await' a=atom !'.' !'(' !'[' { a }
    | [AWAIT] atom ('.' NAME | '[' slices ']' | '(' [arguments] ')')*

slices: ','.slice+ [',']
slice: [expression] ':' [expression] [':' [expression]] | expression
# STRING+'s output is just a hack for now 
atom[expr_ty]:
    | list
    | listcomp
    | tuple
    | group
    | genexp
    | set
    | setcomp
    | dict
    | dictcomp
    | NAME
    | a=STRING+ { asdl_seq_GET(a, 0) }
    | NUMBER
    | a='...' { _Py_Constant(Py_Ellipsis, NULL, EXTRA(a, token_type, a, token_type)) }

list[expr_ty]:
    | a='[' b=[star_named_expressions] c=']' { _Py_List(b, Load, EXTRA(a, token_type, c, token_type)) }
listcomp[expr_ty]:
    | a='[' b=named_expression c=for_if_clauses d=']' { _Py_ListComp(b, c, EXTRA(a, token_type, d, token_type)) }
tuple[expr_ty]:
    | a='(' b=[y=star_named_expression ',' z=[star_named_expressions] { seq_insert_in_front(p, y, z)} ] c=')' {
        _Py_Tuple(b, Load, EXTRA(a, token_type, c, token_type)) }
group[expr_ty]: '(' a=(yield_expr | named_expression) ')' { a }
genexp[expr_ty]:
    | a='(' b=expression c=for_if_clauses d=')' { _Py_GeneratorExp(b, c, EXTRA(a, token_type, d, token_type)) }
set[expr_ty]: a='{' b=expressions_list c='}' { _Py_Set(b, EXTRA(a, token_type, c, token_type)) }
setcomp[expr_ty]:
    | a='{' b=expression c=for_if_clauses d='}' { _Py_SetComp(b, c, EXTRA(a, token_type, d, token_type)) }
dict[expr_ty]:
    | a='{' b=[kvpairs] c='}' { _Py_Dict(get_keys(p, b), get_values(p, b), EXTRA(a, token_type, c, token_type)) }
dictcomp[expr_ty]:
    | a='{' b=kvpair c=for_if_clauses d='}' { _Py_DictComp(b->key, b->value, c, EXTRA(a, token_type, d, token_type)) }
kvpairs[asdl_seq*]: a=','.kvpair+ [','] { a }
kvpair[KeyValuePair*]:
    | '**' a=bitwise_or { key_value_pair(p, NULL, a) }
    | a=expression ':' b=expression { key_value_pair(p, a, b) }
for_if_clauses[asdl_seq*]:
    | a=(y=[ASYNC] 'for' a=star_targets 'in' b=expression c=('if' z=expression { z })*
        { _Py_comprehension(a, b, c, (y == NULL) ? 0 : 1, p->arena) })+ { a }

yield_expr[expr_ty]:
    | a='yield' 'from' b=expression { _Py_YieldFrom(b, EXTRA(a, token_type, b, expr_type)) }
    | a='yield' b=expressions { _Py_Yield(b, EXTRA(a, token_type, b, expr_type)) }
    | a='yield' { _Py_Yield(NULL, EXTRA(a, token_type, a, token_type)) }

arguments: expression for_if_clauses | args [',']
args: '*' expression [',' args] | kwargs | posarg [',' args]  # Weird to make it work
kwargs: ','.kwarg+
posarg: named_expression | '*' expression
kwarg: NAME '=' expression | '*' expression | '**' expression

# NOTE: star_targets may contain *NAME, targets may not.
# NOTE: the !'in' is to handle "for x, in ...".
# TODO: things like {k: v}[k] = v should also be acceptable [star] targets.
star_targets: a=star_target (',' !'in' star_target)* [','] { a }
star_target: '*' bitwise_or | atom t_tail+ | a=star_atom t_tail* { a }
star_atom: a=NAME { store_name(p, a) } | '(' [star_targets] ')' | '[' [star_targets] ']'

targets[asdl_seq*]: a=','.target+ [','] { a }
target[expr_ty]: atom t_tail+ | a=t_atom t_tail* { a }
t_atom[expr_ty]:
    | NAME
    | a='(' b=[targets] c=')' { _Py_Tuple(b, Load, EXTRA(a, token_type, c, token_type)) }
    | a='[' b=[targets] c=']' { _Py_List(b, Load, EXTRA(a, token_type, c, token_type)) }

t_tail: call_tail* (attr_tail | index_tail)
call_tail: '(' ~ [arguments] ')'
attr_tail: '.' NAME
index_tail: '[' ~ slices ']'
