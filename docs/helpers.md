Helper Structs
--------------

The following are all types defined in `pegen/pegen.h`.

##### Memo

Linked list, optimized for quickly finding a given type.

- type: int, either a token or a rule (rules start at 256)
- node: NULL or pointer to AST node OR pointer to token object
- mark: if node != NULL, index into Parser's array of tokens
- next: NULL or pointer to next Memo structure

##### Token

These are in an array linked from Parser.

- type: int, token type (needs only 8 bits)
- bytes: bytes object
- lineno, col_offset, end_lineno, end_col_offset: int
- memo: Pointer to linked list Memo

##### Parser

The Parser needs to point to a PyArena, used for allocating AST nodes and
other things.

- tok: Pointer to tokenizer, CPython's struct tok_state
- tokens: Pointer to array of Token pointers
- mark: index into array of Tokens
- fill: number of valid entries in array of Tokens
- size: total number of entries in array of Tokens
- arena: memory allocation arena (owns all AST, Token, Memo structures allocated)

##### CmpopExprPair

This gets used by the rules that implement comparison, due to the
structure of the Compare AST Object.

- cmpop: cmpop_ty, The comparison operator
- expr: expr_ty, The expression that gets compared

##### KeyValuePair

Used to hold a key value pair, that is needed when parsing the key
value pairs of a dict.

- key: expr_ty, The pair's key
- value: expr_ty, The pair's value

##### NameDefaultPair

Needed so that rules that implement function parameters, can store
names and their default values.

- arg: arg_ty, The argument name
- value: expr_ty, arg's default value

##### SlashWithoutDefault

This is used by the `slash_without_default` rule, which parses two
different kinds of positional only arguments and stores those in this
struct.

- plain_names: `asdl_seq *` of `arg_ty`s or NULL, Positional only
  arguments with no default values
- names_with_defaults: `asdl_seq *` of `NameDefaultsPair`s, Positional
  only arguments with default values

##### StarEtc

This is used by the `star_etc` rules, whose role is to parse the vararg,
the keyword only arguments and the kwarg.

- vararg: `arg_ty` or NULL, The vararg
- kwonlyargs: `asdl_seq *` of `NameDefaultPair`s or NULL, Keyword only arguments
- kwarg: `arg_ty` or NULL, The kwarg

#### AugOperator

Used to encapsulate the value of an operator_ty enum value.

- kind: operator_ty, The augmented assignment operator

#### KeywordOrStarred

This is needed by the `arguments` rule, because a starred expression can appear
after the first keyword argument has been parsed.

- elem: `void *`, The keyword argument or starred expression itself
- is_keyword: `int` (`bool`), Must be 0 for `*args`, 1 for `kw=expr` and `**kwargs`


Helper Preprocessor Defines and Inline Functions
------------------------------------------------

###### `EXTRA_EXPR(head, tail)`

Expands to `head->lineno, head->col_offset, head->end_lineno, head->end_col_offset, p->arena`
and can be used, in order to fetch the positional metadata of an `expr_ty` node.

Example: `return _Py_Name(uni, Load, EXTRA_EXPR(first_name, second_name));`

###### `EXTRA`

Expands to `start_lineno, start_col_offset, end_lineno, end_col_offset, p->arena`
and can be used in grammar actions, so that positional metadata can be fetched in the generated
C code.

Example: `{ _Py_Pass(EXTRA) }`

Note that `EXTRA` *has to* be used in place of its expanded version, because the
line and column offset information does not get computed otherwise.

###### `inline void *CHECK_CALL(Parser *, void *)`

This can be used in grammar actions, in order for the result of a function call
to be checked against NULL (which signifies an error) and the parsing to fail
in case an error occurred. Note that this is not needed for the top level function
call, as it is auto-generated by the parser generator.

Example: `{ _Py_Global(CHECK_CALL(p, map_names_to_ids(p, a)), EXTRA) }`

###### `inline void *CHECK_CALL_NULL_ALLOWED(Parser *, void *)`

Exactly the same functionality with `CHECK_CALL`, except that this should be used
for functions that are allowed to return `NULL` without an error.

###### `CHECK(result)`

Expands to `CHECK_CALL(p, result)` and is used in grammar actions as an alternate
to `CHECK_CALL`, so that the Parser doesn't have to be passed explicitly.

###### `CHECK_NULL_ALLOWED(result)`

Same as `CHECK(result)` but this is used to replace calls to `CHECK_CALL_NULL_ALLOWED`.


Helper Functions
----------------

###### `asdl_seq *singleton_seq(Parser *p, void *a)`
Creates a single-element `asdl_seq *` that contains `a`.

###### `asdl_seq *seq_insert_in_front(Parser *p, void *a, asdl_seq *seq)`
Creates a copy of `seq` and prepends `a` to it.

###### `asdl_seq *seq_flatten(Parser *p, asdl_seq *seq)`
Flattens an `asdl_seq *` of `asdl_seq *`s.

###### `expr_ty join_names_with_dot(Parser *p, expr_ty first_name, expr_ty second_name)`
Creates a new name of the form <first_name>.<second_name>.

###### `int seq_count_dots(asdl_seq *seq)`
Counts the total number of dots in `seq`s tokens.

###### `alias_ty alias_for_star(Parser *p)`
Creates an alias with `*` as the identifier name.

###### `asdl_seq *map_names_to_ids(Parser *p, asdl_seq *seq)`
Creates a new `asdl_seq *` with the identifiers of all the names in `seq`.

###### `CmpopExprPair *cmpop_expr_pair(Parser *p, cmpop_ty cmpop, expr_ty expr)`
Constructs a `CmpopExprPair`.

###### `asdl_int_seq *get_cmpops(Parser *p, asdl_seq *)`
Extract all the `cmpop`s out of an `asdl_seq*` of `CmpopExprPair*`s into a new `asdl_int_seq*`.

###### `asdl_seq *get_exprs(Parser *, asdl_seq *)`
Extract all the `expr`s out of an `asdl_seq*` of `CmpopExprPair*`s into a new `asdl_seq*`.

###### `expr_ty set_expr_context(Parser *p, expr_ty expr, expr_context_ty ctx)`
Creates an `expr_ty` equivalent to `expr` but with `ctx` as context.

###### `KeyValuePair *key_value_pair(Parser *p, expr_ty key, expr_ty value)`
Constructs a `KeyValuePair` that is used when parsing a dict's key value pairs.

###### `asdl_seq *get_keys(Parser *p, asdl_seq *seq)`
Extracts all keys from an `asdl_seq*` of `KeyValuePair*`s.

###### `asdl_seq *get_values(Parser *p, asdl_seq *seq)`
Extracts all values from an `asdl_seq*` of `KeyValuePair*`s.

###### `NameDefaultPair *name_default_pair(Parser *p, arg_ty arg, expr_ty value)`
Constructs a `NameDefaultPair`.

###### `SlashWithDefault *slash_with_default(Parser *p, asdl_seq *plain_names, asdl_seq *names_with_defaults)`
Constructs a `SlashWithDefault`.

###### `StarEtc *star_etc(Parser *p, arg_ty vararg, asdl_seq *kwonlyargs, arg_ty kwarg)`
Constructs a `StarEtc`.

###### `arguments_ty make_arguments(Parser *p, asdl_seq *slash_without_default, SlashWithDefault *slash_with_default, asdl_seq *plain_names, asdl_seq *names_with_default, StarEtc *star_etc)`
Constructs an `arguments_ty` object out of all the parsed constructs in the `parameters` rule.

###### `arguments_ty empty_arguments(Parser *p)`
Constructs an empty `arguments_ty` object, that gets used when a function accepts no arguments.

###### `asdl_seq *augoperator(Parser *p, operator_ty kind)`
Creates an `AugOperator` encapsulating the operator type provided in *kind*.

###### `stmt_ty function_def_decorators(Parser *p, asdl_seq *decorators, stmt_ty function_def)`
Construct a `FunctionDef` equivalent to `function_def`, but with `decorators`.

###### `stmt_ty class_def_decorators(Parser *p, asdl_seq *decorators, stmt_ty class_def)`
Construct a `ClassDef` equivalent to `class_def`, but with `decorators`.

###### `KeywordOrStarred *keyword_or_starred(Parser *, void *, int)`
Constructs a `KeywordOrStarred`.

###### `asdl_seq *seq_extract_starred_exprs(Parser *p, asdl_seq *kwargs)`
Extract the starred expressions of an `asdl_seq*` of `KeywordOrStarred*`s.

###### `asdl_seq *seq_delete_starred_exprs(Parser *p, asdl_seq *kwargs)`
Return a new `asdl_seq*` with only the keywords in `kwargs`.

###### `expr_ty concatenate_strings(Parser *p, asdl_seq *)`
Receives a `asdl_seq` that must contain constant strings and
returns a new string with the concatenation of all of them.
