from typing import Any, Dict, List, Optional, IO, Text

from pegen.grammar import GrammarVisitor
from pegen import grammar
from pegen.parser_generator import dedupe, ParserGenerator

MODULE_PREFIX = """\
#!/usr/bin/env python3.8
# @generated by pegen.py from {filename}
from __future__ import annotations

import ast
import sys
import tokenize

from pegen.parser import memoize, memoize_left_rec, logger, Parser

"""
MODULE_SUFFIX = """

if __name__ == '__main__':
    from pegen.parser import simple_parser_main
    simple_parser_main(GeneratedParser)
"""


class PythonCallMakerVisitor(GrammarVisitor):

    def __init__(self, parser_generator: ParserGenerator):
        self.gen = parser_generator
        self.cache: Dict[Any, Any] = {}

    def visit_NameLeaf(self, node):
        name = node.value
        if name in ('NAME', 'NUMBER', 'STRING', 'CUT', 'CURLY_STUFF'):
            name = name.lower()
            return name, f"self.{name}()"
        if name in ('NEWLINE', 'DEDENT', 'INDENT', 'ENDMARKER', 'ASYNC', 'AWAIT'):
            return name.lower(), f"self.expect({name!r})"
        return name, f"self.{name}()"

    def visit_StringLeaf(self, node):
        return 'literal', f"self.expect({node.value})"

    def visit_Rhs(self, node):
        if node in self.cache:
            return self.cache[node]
        if len(node.alts) == 1 and len(node.alts[0].items) == 1:
            self.cache[node] = self.visit(node.alts[0].items[0])
        else:
            name = self.gen.name_node(node)
            self.cache[node] = name, f"self.{name}()"
        return self.cache[node]

    def visit_NamedItem(self, node):
        name, call = self.visit(node.item)
        if node.name:
            name = node.name
        return name, call

    def lookahead_call_helper(self, node):
        name, call = self.visit(node.node)
        head, tail = call.split('(', 1)
        assert tail[-1] == ')'
        tail = tail[:-1]
        return head, tail

    def visit_PositiveLookahead(self, node):
        head, tail = self.lookahead_call_helper(node)
        return None, f"self.positive_lookahead({head}, {tail})"

    def visit_NegativeLookahead(self, node):
        head, tail = self.lookahead_call_helper(node)
        return None, f"self.negative_lookahead({head}, {tail})"

    def visit_Opt(self, node):
        name, call = self.visit(node.node)
        return "opt", f"{call},"  # Note trailing comma!

    def visit_Repeat0(self, node):
        if node in self.cache:
            return self.cache[node]
        name = self.gen.name_loop(node.node, False)
        self.cache[node] = name, f"self.{name}(),"  # Also a trailing comma!
        return self.cache[node]

    def visit_Repeat1(self, node):
        if node in self.cache:
            return self.cache[node]
        name = self.gen.name_loop(node.node, True)
        self.cache[node] = name, f"self.{name}()"  # But no trailing comma here!
        return self.cache[node]

    def visit_Group(self, node):
        return self.visit(node.rhs)


class PythonParserGenerator(ParserGenerator, GrammarVisitor):

    def __init__(self, rules: Dict[str, grammar.Rule], file: Optional[IO[Text]]):
        super().__init__(rules, file)
        self.callmakervisitor = PythonCallMakerVisitor(self)

    def generate(self, filename: str) -> None:
        self.print(MODULE_PREFIX.format(filename=filename))
        self.print("class GeneratedParser(Parser):")
        while self.todo:
            for rulename, rule in list(self.todo.items()):
                del self.todo[rulename]
                self.print()
                with self.indent():
                    self.visit(rule)
        self.print(MODULE_SUFFIX.rstrip('\n'))

    def visit_Rule(self, node):
        is_loop = node.is_loop()
        rhs = node.flatten()
        if node.left_recursive:
            if node.leader:
                self.print("@memoize_left_rec")
            else:
                # Non-leader rules in a cycle are not memoized,
                # but they must still be logged.
                self.print("@logger")
        else:
            self.print("@memoize")
        self.print(f"def {node.name}(self):")
        with self.indent():
            self.print(f"# {node.name}: {rhs}")
            if node.nullable:
                self.print(f"# nullable={node.nullable}")
            self.print("mark = self.mark()")
            if is_loop:
                self.print("children = []")
            self.visit(rhs, is_loop=is_loop)
            if is_loop:
                self.print("return children")
            else:
                self.print("return None")

    def visit_NamedItem(self, node, names):
        name, call = self.callmakervisitor.visit(node.item)
        if node.name:
            name = node.name
        if not name:
            self.print(call)
        else:
            if name != 'cut':
                name = dedupe(name, names)
            self.print(f"({name} := {call})")

    def visit_Rhs(self, node, is_loop=False):
        if is_loop:
            assert len(node.alts) == 1
        for alt in node.alts:
            self.visit(alt, is_loop=is_loop)

    def visit_Alt(self, node, is_loop):
        names: List[str] = []
        self.print("cut = False")  # TODO: Only if needed.
        if is_loop:
            self.print("while (")
        else:
            self.print("if (")
        with self.indent():
            first = True
            for item in node.items:
                if first:
                    first = False
                else:
                    self.print("and")
                self.visit(item, names=names)
        self.print("):")
        with self.indent():
            action = node.action
            if not action:
                action = f"[{', '.join(names)}]"
            else:
                assert action[0] == '{' and action[-1] == '}', repr(action)
                action = action[1:-1].strip()
            if is_loop:
                self.print(f"children.append({action})")
                self.print(f"mark = self.mark()")
            else:
                self.print(f"return {action}")
        self.print("self.reset(mark)")
        # Skip remaining alternatives if a cut was reached.
        self.print("if cut: return None")  # TODO: Only if needed.
