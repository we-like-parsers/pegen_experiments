import ast
import re
from typing import Optional, IO, Text, List, Dict, Tuple

from pegen.grammar import GrammarVisitor
from pegen import grammar
from pegen.parser_generator import dedupe, ParserGenerator as BaseParserGenerator
from pegen.tokenizer import exact_token_types

EXTENSION_PREFIX = """\
// @generated by pegen.py from {filename}

#include "pegen.h"
"""
EXTENSION_SUFFIX = """
// TODO: Allow specifying a module name

static PyObject *
parse_file(PyObject *self, PyObject *args)
{
    const char *filename;

    if (!PyArg_ParseTuple(args, "s", &filename))
        return NULL;
    return run_parser(filename, (void *)start_rule, %(mode)s);
}

static PyMethodDef ParseMethods[] = {
    {"parse",  parse_file, METH_VARARGS, "Parse a file."},
    {NULL, NULL, 0, NULL}        /* Sentinel */
};

static struct PyModuleDef parsemodule = {
    PyModuleDef_HEAD_INIT,
    .m_name = "parse",
    .m_doc = "A parser.",
    .m_methods = ParseMethods,
};

PyMODINIT_FUNC
PyInit_parse(void)
{
    PyObject *m = PyModule_Create(&parsemodule);
    if (m == NULL)
        return NULL;

    return m;
}

// The end
"""


class CallMakerVisitor(GrammarVisitor):
    def __init__(self, parser_generator):
        self.gen = parser_generator
        self.cache = {}

    def visit_NameLeaf(self, node):
        name = node.value
        if name in ('NAME', 'NUMBER', 'STRING', 'CUT', 'CURLY_STUFF'):
            name = name.lower()
            return f"{name}_var", f"{name}_token(p)"
        if name in ('NEWLINE', 'DEDENT', 'INDENT', 'ENDMARKER'):
            name = name.lower()
            return f"{name}_var", f"{name}_token(p)"
        return f"{name}_var", f"{name}_rule(p)"

    def visit_StringLeaf(self, node):
        val = ast.literal_eval(node.value)
        if re.match(r'[a-zA-Z_]\w*\Z', val):
            return 'keyword', f'keyword_token(p, "{val}")'
        else:
            assert val in exact_token_types, f"{node.value} is not a known literal"
            type = exact_token_types[val]
            return 'literal', f'expect_token(p, {type})'

    def visit_Rhs(self, node):
        if node in self.cache:
            return self.cache[node]
        if len(node.alts) == 1 and len(node.alts[0].items) == 1:
            self.cache[node] = self.visit(node.alts[0].items[0])
        else:
            name = self.gen.name_node(node)
            self.cache[node] = f"{name}_var", f"{name}_rule(p)"
        return self.cache[node]

    def visit_NamedItem(self, node):
        name, call = self.visit(node.item)
        if node.name:
            name = node.name
        return name, call

    def lookahead_call_helper(self, node):
        name, call = self.visit(node.node)
        head, tail = call.split('(', 1)
        assert tail[-1] == ')'
        tail = tail[:-1]
        return head, tail

    def visit_PositiveLookahead(self, node):
        head, tail = self.lookahead_call_helper(node)
        return None, f"positive_lookahead({head}, {tail})"

    def visit_NegativeLookahead(self, node):
        head, tail = self.lookahead_call_helper(node)
        return None, f"negative_lookahead({head}, {tail})"

    def visit_Opt(self, node):
        name, call = self.visit(node.node)
        return "opt_var", f"{call}, 1"  # Using comma operator!

    def visit_Repeat0(self, node):
        if node in self.cache:
            return self.cache[node]
        name = self.gen.name_loop(node.node, False)
        self.cache[node] = f"{name}_var", f"{name}_rule(p)"
        return self.cache[node]

    def visit_Repeat1(self, node):
        if node in self.cache:
            return self.cache[node]
        name = self.gen.name_loop(node.node, True)
        self.cache[node] = f"{name}_var", f"{name}_rule(p)"  # But not here!
        return self.cache[node]

    def visit_Group(self, node):
        return self.visit(node.rhs)


class ParserGenerator(BaseParserGenerator, GrammarVisitor):
    def __init__(self, rules: grammar.Rules, file: Optional[IO[Text]]):
        super().__init__(rules.rules, file)
        self.callmakervisitor = CallMakerVisitor(self)

    def generate(self, filename: str) -> None:
        self.collect_todo()
        self.print(EXTENSION_PREFIX.format(filename=filename))
        for i, rulename in enumerate(self.todo, 1000):
            self.print(f"#define {rulename}_type {i}")
        self.print()
        for rulename, rule in self.todo.items():
            if rule.is_loop():
                type = 'asdl_seq *'
            elif rule.type:
                type = rule.type + ' '
            else:
                type = 'void *'
            self.print(f"static {type}{rulename}_rule(Parser *p);")
        self.print()
        while self.todo:
            for rulename, rule in list(self.todo.items()):
                del self.todo[rulename]
                self.print()
                self.visit(rule)
        mode = int(self.rules['start'].type == 'mod_ty')
        self.print(EXTENSION_SUFFIX.rstrip('\n') % dict(mode=mode))

    def visit_Rule(self, node):
        is_loop = node.is_loop()
        is_repeat1 = node.name.startswith('_loop1')
        memoize = not node.leader
        rhs = node.flatten()
        if is_loop:
            type = 'asdl_seq *'
        elif node.type:
            type = node.type
        else:
            type = 'void *'

        self.print(f"// {node}")
        if node.left_recursive:
            self.print(f"static {type} {node.name}_raw(Parser *);")

        self.print(f"static {type}")
        self.print(f"{node.name}_rule(Parser *p)")

        if node.left_recursive:
            self.print("{")
            with self.indent():
                self.print(f"{type} res = NULL;")
                self.print(f"if (is_memoized(p, {node.name}_type, &res))")
                with self.indent():
                    self.print("return res;")
                self.print("int mark = p->mark;")
                self.print("int resmark = p->mark;")
                self.print("while (1) {")
                with self.indent():
                    self.print(f"update_memo(p, mark, {node.name}_type, res);")
                    self.print("p->mark = mark;")
                    self.print(f"void *raw = {node.name}_raw(p);")
                    self.print("if (raw == NULL || p->mark <= resmark)")
                    with self.indent():
                        self.print("break;")
                    self.print("resmark = p->mark;")
                    self.print("res = raw;")
                self.print("}")
                self.print("p->mark = resmark;")
                self.print("return res;")
            self.print("}")
            self.print(f"static {type}")
            self.print(f"{node.name}_raw(Parser *p)")

        self.print("{")
        with self.indent():
            if is_loop:
                self.print(f"void *res = NULL;")
            else:
                self.print(f"{type} res = NULL;")
            if memoize:
                self.print(f"if (is_memoized(p, {node.name}_type, &res))")
                with self.indent():
                    self.print("return res;")
            self.print("int mark = p->mark;")
            if is_loop:
                self.print("void **children = PyMem_Malloc(0);")
                self.print(f'if (!children) panic("malloc {node.name}");')
                self.print("ssize_t n = 0;")
            self.visit(rhs, is_loop=is_loop, rulename=node.name if memoize else None)
            if is_loop:
                if is_repeat1:
                    self.print("if (n == 0) {")
                    with self.indent():
                        self.print("PyMem_Free(children);")
                        self.print("return NULL;")
                    self.print("}")
                self.print("asdl_seq *seq = _Py_asdl_seq_new(n, p->arena);")
                self.print(f'if (!seq) panic("asdl_seq_new {node.name}");')
                self.print("for (int i = 0; i < n; i++) asdl_seq_SET(seq, i, children[i]);")
                self.print("PyMem_Free(children);")
                if node.name:
                    self.print(f"insert_memo(p, mark, {node.name}_type, seq);")
                self.print("return seq;")
            else:
                ## gen.print(f'fprintf(stderr, "Fail at %d: {self.name}\\n", p->mark);')
                self.print("res = NULL;")
        if not is_loop:
            self.print("  done:")
            with self.indent():
                if memoize:
                    self.print(f"insert_memo(p, mark, {node.name}_type, res);")
                self.print("return res;")
        self.print("}")

    def visit_NamedItem(self, node, names: List[str]):
        name, call = self.callmakervisitor.visit(node)
        if not name:
            self.print(call)
        else:
            if name != 'cut':
                name = dedupe(name, names)
            self.print(f"({name} = {call})")

    def visit_Rhs(self, node, is_loop: bool, rulename: Optional[str]):
        if is_loop:
            assert len(node.alts) == 1
        vars = {}
        for alt in node.alts:
            vars.update(self.collect_vars(alt))
        for v, type in sorted(vars.items()):
            if not type:
                type = 'void *'
            else:
                type += ' '
            self.print(f"{type}{v};")
        for alt in node.alts:
            self.visit(alt, is_loop=is_loop, rulename=rulename)

    def visit_Alt(self, node, is_loop: bool, rulename: Optional[str]):
        self.print(f"// {node}")
        names = []
        if is_loop:
            self.print("while (")
        else:
            self.print("if (")
        with self.indent():
            first = True
            for item in node.items:
                if first:
                    first = False
                else:
                    self.print("&&")
                self.visit(item, names=names)
        self.print(") {")
        with self.indent():
            action = node.action
            if not action:
                ## self.print(f'fprintf(stderr, "Hit at %d: {node}, {names}\\n", p->mark);')
                if len(names) > 1:
                    self.print(f"res = CONSTRUCTOR(p, {', '.join(names)});")
                else:
                    self.print(f"res = {names[0]};")
            else:
                assert action[0] == '{' and action[-1] == '}', repr(action)
                action = action[1:-1].strip()
                self.print(f"res = {action};")
                ## self.print(f'fprintf(stderr, "Hit with action at %d: {node}, {names}, {action}\\n", p->mark);')
            if is_loop:
                self.print("children = PyMem_Realloc(children, (n+1)*sizeof(void *));")
                self.print(f'if (!children) panic("realloc {rulename}");')
                self.print(f"children[n++] = res;")
                self.print("mark = p->mark;")
            else:
                if rulename:
                    self.print(f"insert_memo(p, mark, {rulename}_type, res);")
                self.print(f"goto done;")
        self.print("}")
        self.print("p->mark = mark;")

    def collect_vars(self, node) -> Dict[str, str]:
        names = []
        types = {}
        for item in node.items:
            name, type = self.add_var(item, names)
            types[name] = type
        return types

    def add_var(self, node, names: List[str]) -> Tuple[str, str]:
        name, call = self.callmakervisitor.visit(node.item)
        type = None
        if name != 'cut':
            if name.endswith('_var'):
                rulename = name[:-4]
                rule = self.rules.get(rulename)
                if rule is not None:
                    if rule.is_loop():
                        type = 'asdl_seq *'
                    else:
                        type = rule.type
                elif name.startswith('_loop'):
                    type = 'asdl_seq *'
            if node.name:
                name = node.name
            name = dedupe(name, names)
        return name, type
